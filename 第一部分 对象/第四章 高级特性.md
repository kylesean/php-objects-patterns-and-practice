## 高级特性

我们已经知道，借助类型提示和访问控制可以更好地控制类的接口。本章将继续深入探讨 PHP 对面向对象开发的支持。

本章包括以下内容。

- [ ] 静态方法和属性： 通过类而不是对象来访问数据和功能。
- [ ] 抽象类和接口：设计和实现相分离。
- [ ] 错误处理：异常
- [ ] Final 类和方法：限制继承。
- [ ] 拦截器方法：自动委托。
- [ ] 析构方法：对象销毁前的清理工作。
- [ ] 克隆对象：创建对象的副本。
- [ ] 把对象解析成字符串：创建摘要型方法。
- [ ] 回调：用匿名函数为组件添加功能。

### 静态属性和方法
第 3 章的所有例子使用的都是对象。我们把类当做生成对象的模板，把对象作为活动组件，对象的方法可以被调用，对象的属性可以被访问。之前的例子也暗示了，面向对象编程中的实际操作都是通过类的实例（而不是类的本身）完成的。毕竟，类仅仅是对象的模板。

事实并非如此简单。我们不仅可以通过对象访问方法和属性，还可以通过类来访问它们。这样的方法和属性是 “静态” 的（static），必须用 static 关键字来声明。

```
class StaticExample
{
  static public $aNum = 0;
  public static function sayHello()
  {
    print "Hello";
  }
}
```
静态方法是以类作为作用域的函数。静态方法不能访问这个类的普通属性，因为那些属性属于一个对象，但可以访问静态属性。如果修改了一个静态属性，那么这个类的所有实例都能访问到这个新值。

因为是通过类而不是实例来访问静态元素，所以访问静态元素时不需要引用对象的变量，而是使用 `::` (两个冒号)来连接类名和属性或类名和方法。

```
print StaticExample::$aNum;
StaticExample::sayHello();

```
在第 3 章我们已经熟悉了这个语法。我们曾使用 `::` 和 parent 类来访问覆写的方法。现在和之前一样，只不过访问的是类而不是对象数据。一个子类可以使用 parent 关键字来访问父类，而不使用其类名。要从当前类（而不是子类）中访问静态方法和属性，可以使用 `self` 关键字。self 指向当前类，就像伪变量 $this 指向当前对象一样。因此，在 StaticExample 类的外部可以使用其类名访问属性 $aNum:

```
StaticExample::$aNum;
```

而在 StaticExample 类内部，可以使用 self 关键字：

```
class StaticExample
{
  static public $aNum = 0;
  public static function sayHello()
  {
    self::$aNum++;
    print "hello (".self::$aNum.")\n";
  }
}
```

> 注意：只有在使用 parent 关键字调用方法的时候，才能对一个非静态方法进行静态形式的调用，言外之意就是其他任何情况都需要先生成一个对象，然后使用 `->` 符号调用对象中的方法。除非是访问一个被覆写的方法，否则永远只能使用 `::` 访问被明确声明为 static 的方法或属性。在文档中，你将会经常看到使用 static 语法来引用方法或属性。这并不意味着其中的方法或属性必须是静态的，只不过说明它属于特定的类。例如，ShopProductWriter 类的方法 write() 可以表示为 ShopProductWriter::write()，虽然 write() 方法并不是静态的。你将在本书中看到这种语法形式。


根据定义，我们不能在对象中调用静态方法，因此静态方法和属性又被称为类变量和属性，因此不能在静态方法中使用伪变量 $this。

那么，我们为什么要使用静态方法或属性呢？因为静态元素有很多有用的特性。首先，它们在代码中的任何地方都可用（假设你可以访问该类）。也就是说，你不需要在对象间传递类的实例，也不需要将实例存放在全局变量中，就可以访问类中的方法。其次，类的每个实例都可以访问类中定义的静态属性，所以你可以利用静态属性来设置值，该值可以被类的所有对象使用。最后，不需要实例对象就能访问静态属性或方法，这样我们就不用为了获取一个简单的功能而实例化对象。

下面构建 ShopProduct 类的一个静态方法来自动实例化 ShopProduct 对象。使用 SQLite 定义表 products，如下所示：

```
CREATE TABLE products(
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            type TEXT,
                            firstname TEXT,
                            mainname TEXT,
                            title TEXT,
                            price float,
                            numpages int,
                            playlength int,
                            discount int )
                      
)
```
下面构建 getInstance() 方法，其参数为数据库记录的 ID 和 PDO 对象。用它们获取数据库的一行记录，然后返回 ShopProduct 对象。我们可以把这些方法添加到上一章创建的 ShopProduct 类中。PDO 代表 PHP Data Object。PDO 类为不同的数据库应用程序提供了统一的接口。

```
// ShopProduct class...

private $id = 0;
// ...

public function setId(int $id)
{
  $this->id = $id;
}
// ...

public static function getInstance(int $id, \PDO $pdo): ShopProduct
{
  $stmt = $pdo->prepare("select * from products where id =?");
  $result = $stmt->execute([$id]);
  $row = $stmt->fetch();
  if (empty($row)) {
    return null;
  }

  if ($row['type'] == 'book') {
    $product = new BookProduct(
      $row['title'],
      $row['firstname'],
      $row['mainname'],
      (float) $row['price'],
      (int) $row['numpages']
    );
  } elseif ($row['type'] == 'cd') {
    $product = new CdProduct(
      $row['title'],
      $row['firstname'],
      $row['mainname'],
      (float) $row['price'],
      (int) $row['playlength']
    );
  } else {
    $firstname = (is_null($row['firstname'])) ? "" : $row['firstname'];
    $product = new ShopProduct(
      $row['title'],
      $firstname,
      $row['mainname'],
      (float) $row['price']
    ); 
  }
  $product->setId((int) $row['id']);
  $product->setInstance((int) $row['discount']);
  return $product;
}
```
如上所示，getInstance() 方法根据类型标志聪明地判断需要实例化的精确范围，返回特定类型的 ShopProduct 对象。为了保持代码简洁，我们没有进行任何错误处理。在真实项目中，我们并不能完全相信 PDO 对象初始化后就一定能够与正确的数据库通信。事实上，我们可以把 PDO 封装在类中来确保这一行为。你可以在第 13 章中了解更多与面向对象程序设计和数据库相关的信息。

这个方法在类中会比在对象中更有用。我们可以轻松地将原始数据转换为一个对象，而不需要一开始就使用 ShopProduct 对象。这个方法并没有使用任何实例的属性和方法，所以没有理由不把它定义为 static。只要有一个有效 PDO 对象，我们就可以在程序的任何地方调用这个方法：

```
$dsn = "sqlite://home/bob/projects/products.db";
$pdo = new \PDO($dsn, null, null);
$pdo->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);
$obj = ShopProduct::getInstance(1, $pdo);
```
这样的方法就像 “工厂” 一样，可以接受原始数据（比如一系列数据或配置信息），然后据此产生对象。 “工厂” 这一术语在代码设计中用于生成对象实例。我们会在后面介绍工厂设计模式的例子。

某些方面，这个例子解决了大部分问题。尽管我们使用 `ShopProduct::getInstance()` 方法从系统中的任何地方都可以访问，而不需要 ShopProduct 实例，但是我们还是需要程序提供一个 PDO 对象。

父类深入了解子类的情况是种好的实践么？不是。对于，在哪里获取关键对象和值以及类之间的依赖关系程度的了解在面向对象编程中非常普遍。第 9 章将研究对象生成的各种方法。 

### 常量属性

有些属性不能改变，例如 42 是生命、宇宙及万事万物的终极答案（出自道格拉斯 亚当斯的著名科幻小说《银河系漫游指南》）。错误和状态标志经常需要被硬编码（硬编码的值始终不变）进类中。虽然它们是公共的、可静态访问的，但是客户端代码不能改变它们。

PHP5 可以在类中定义常量属性。和全局变量一样，类常量一旦设置后就不能改变。常量属性用 const 关键字来声明。常量不像常规属性那样以美元符号开头。按照惯例，只能用大写字母来命名常量，如下所示：

```
class ShoProduct
{
  const AVAILABLE = 0;
  const OUT_OF_STOCK = 1;
  // ...
}
```
常量属性只能包含最原始值。你不能将对象分配给常量。就像静态属性一样，通过类访问常量属性，而不是通过实例。当你引用一个常量时，不需要引导符，就像你定义了一个没有美元符号的常数。
```
print ShopProduct::AVAILABLE;
```
尝试给已经声明过的常量赋值就会引起解析错误。

当需要在类的所有实例中都能访问某个属性，并且属性值无需改变时，应该使用常量。

### 抽象类

抽象类不能被直接实例化。抽象类中只定义（或部分实现）任何可能继承它的子类需要的接口。

你可以用 abstract 关键字定义一个抽象类。我们将上一章创建的 ShopProductWriter 类重新定义为抽象类。

```
abstract class ShopProductWriter
{
  protected $products = [];

  public function addProduct(ShopProduct $shopProduct)
  {
    $this->products[] = $shopProduct;
  }
}
```

和普通的类一样，可以创建抽象类和方法和属性，但是实例化一个抽象类会产生下面的错误：

```
$writer = new ShopProductWriter();
```
输出：
```
Error: Cannot instantiate abstract class popp\ch04\batch03\ShopProductWriter
```

大多数情况下，抽象类至少只包含一个抽象方法。抽象方法用 abstract 关键字声明，其中不能有具体内容。你可以像声明普通类方法那样声明抽象方法，但要以分号而不是方法体结束。下面我们为 ShopProductWriter 类添加抽象方法 write():

```
abstract class ShopProductWriter
{
  protected $products = [];

  public function addProduct(ShopProduct $shopProduct)
  {
    $this->products[] = $shopProduct;
  }

  abstract public function write();
}
```

抽象方法创建后，要确保所有子类中都实现了该方法，但实现类的细节可先不确定。

假如创建了一个继承自 ShopProductWriter 的类，但是不实现 write() 方法：

```
class ErroredWriter extends ShopProductWriter
{

}
```
那么程序将出现下面的错误：

```
PHP Fatal error: Class ErroredWriter contains 1 abstract method and
must therefore be declared abstract or implement the remaining methods
(ShopProductWriter::write) in...
```
所以，抽象类的每个子类都必须实现抽象类中的所有抽象方法，或者把它们自身也声明为抽象。继承类不仅仅负责简单实现抽象类中的方法，还必须重新声明方法。新的实现方法的访问控制不能比抽象方法的访问控制更严格。新的实现方法的参数个数应该和抽象方法的参数个数一样，重新生成对应的类型提示。

下面我们来定义 ShopProductWriter() 的两个实现：

```
class XmlProductWriter extends ShopProductWriter
{
  public function write()
  {
    $writer = new \XMLWriter();
    $writer->openMemory();
    $writer->startDocument('1.0', 'UTF-8');
    $writer->startElement("products");
    foreach ($this->products as $shopProduct) {
        $writer->startElement("product");
        $writer->writeAttribute("title", $shopProduct->getTitle());
        $writer->startElement("summary");
        $writer->text($shopProduct->getSummaryLine());
        $writer->endElement(); // summary
        $writer->endElement(); // product
      }
      $writer->endElement(); // products
      $writer->endDocument();
      print $writer->flush();
  }
}
```
```
class TextProductWriter extends ShopProductWriter
{
    public function write()
    {
        $str = "PRODUCTS:\n";
        foreach ($this->products as $shopProduct) {
            $str .= $shopProduct->getSummaryLine()."\n";
        }
        print $str;
    }
}
```
我们创建了两个类，每个类都有自己的 write() 方法实现。第一个输出 XML，第二个输出文本。现在使用 ShopProductWriter 对象的方法不知道接收到的对象是这两个类中哪个类的实例，但是可以确定该对象一定实现了 write() 方法。值得注意的是，在将 $products 按照数组处理前，我们并不检查它的类型，因为这个属性在 ShopProductWriter 中已初始化为空数组。


### 接口
抽象类提供了具体实现的标准，而接口（interface）则是纯粹的模板。接口只能定义功能，而不包含实现的内容。接口可以用关键字 interface 来声明。接口可以包含属性和方法声明，但是方法体为空。

定义个接口：

```
interface Chargeable()
{
  public function getPrice(): float;
}
```
如上所示，接口和类非常相似。包含此接口的任何类都要实现接口中定义的所有方法，否则该类必须声明为 abstract。一个类可以在其声明中使用 implements 关键字来实现一个接口，一旦实现了这一点，实现接口的过程与继承只包含抽象方法的抽象类相同。现在将 ShoProduct 类实现 Chargeable。

```
class ShopProduct implements Chargeable
{
  // ...
  protected $price;
  // ...

  public function getPrice(): float
  {
    return $this->price;
  }
  // ...
}
```
ShopProduct 类已经有一个 getPrice() 方法，那么为什么要实现 Chargeable 接口呢？答案与类型有关。实现类接受了它所继承的类的类型和实现的接口。

也就是说， CdProduct 类同时属于：

```
CdProduct
ShopProduct
Chargeable
```
这可以被客户端代码很方便地使用。你只要知道一个对象的类型，就知道它能做什么。考虑下这个方法：

```
public function cdInfo(CdProduct $prod) 
{
  // ...
}
```
现在知道 $prod 对象除了拥有 ShopProduct 类和 Chargeable 接口中定义的所有方法之外，还有 getPlayLength() 方法。

传递相同的对象作为参数，方法

```
public function addProduct(ShopProduct $prod)
{
  // ...
}
```
知道 $prod 支持 ShopProduct 中的所有方法：但是如果没有进一步测试，就无法得知 getPlayLength() 方法的存在。

再次传递相同的 CdProduct 对象作为参数，方法

```
public functon addChargeableItem(Chargeable $item)
{
  // ...
}
```
不知道关于 ShopProduct 或 CdProduct 类型的一切。这个方法只关注 $item 参数是否包含 getPrice() 方法。

由于任何类都可以实现接口（实际上，一个类可以实现多个接口），接口可以有效地将不相关的类型联结起来。我们可以定义一个全新的类来实现 Chargeable 接口：

```
class Shipping implements Chargeable
{
  public function getPrice(): float
  {
      // ...
  }
}
```
将 Shipping 对象传递给 addChargeableItem() 方法，就像传递给 ShopProduct 对象一样。

使用 Chargeable 对象的客户端代码可以随时调用 getPrice() 方法，而对象中的任何其他方法都要和其类型关联起来，无论是通过对象自己的类、父类还是其他接口。这些都是客户端代码不需要关注的。

一个类可以同时继承一个父类和实现任意个接口。extends 字句应该在 implements 字句之前：

```
class Consultancy extends TimedService implements Bookable, Chargeable
{
  // ...
}
```
注意，Consultancy 类实现了不止一个接口，此时可将它们放在 implements 关键字之后，并将其以逗号分隔。

PHP 只支持继承自一个父类，因此 extends 关键字只能在一个类名之前。


### Trait

我们已经看到，接口可以帮助我们更好地管理代码，跟 Java 一样，PHP 不支持多继承。换句话说，PHP 中的类只能有一个父类，但是你可以按照类的约束实现尽可能多的接口，对于每个实现的接口，类都有相应的类型。所以接口本身只提供类型而不负责实现，但是如果你想跨继承结构共享一个实现怎么办？好在 PHP5.4 引入了 trait，可以帮助你做到这点。

> 译者：trait 有人翻译为性状，我觉得太难听，还是不翻为好，就跟 Ruby 里的 mixin 一样为了多继承而引入的新的特性，但又不像传统支持多继承的语言复杂，例如 C++ 。

Trait 的结构跟类相似，它本身不可以实例化，但可以并入到其他类中。Trait 中定义的任何方法都可以在引入它的类中使用，它更改了类的结构，但不会更改其类型。可以看做包含类（include class）来理解 trait。我们来看看 trait 要解决的问题是啥。

假设ShopProduct 类中有个 calculateTax() 方法。

```
class  ShopProduct 
{
  private $taxrate = 17;

  // ...

  public function calculateTax(float $price): float
  {
    return (($this->taxrate / 100) * $price);
  }
}

```
```
$p = new ShoProduct("Fine Soap", "", "Bob's Bathroom", 1.33);
print $p->calculateTax(100) . "\n";
```
calculateTax() 方法接受 $price 参数，并根据私有属性 $taxrate 计算销售税额。当然，子类是可以访问 calculateTax() 的，但是如果是完全不同层次的类呢？想象一下一个名为 UtilityService 的类继承另一个 Service 类。如过 UtilityService 需要使用相同的例行程序，那么 calculateTax() 方法势必要重复定义。

```
abstract class Service
{
  // service oriented stuff
}

class UtilityService extends Service
{
  private $taxrate = 17;

  function calculateTax(float $price): float
  {
    return ( ( $this->taxrate/100 ) * $price );
  }
}

$u = new UtilityService;
print $u->calculateTax(100) . "\n";  
```
### 定义和使用 Trait

本书介绍的面向对象设计的核心之一便是**删除重复**。正如你在第 11 章节看到的，这种解决重复性问题的方案将其归纳为可重用的策略类。trait 提供了另一种解决方法，或许不太优雅，但肯定有效。

下面我声明了一个 trait 并且定义了 calculateTax() 方法，然后包含到 ShopProduct 和 UtilityService 两个类中：

```
trait PriceUtilities
{
  private $taxrate = 17;

  public function calculateTax(float $price): float
  {
    return (($this->taxrate / 100) * $price);
  }

  // other utilities
}
```
```
class ShopProduct
{
  use PriceUtilities;
}
```

```
abstract class Service
{
  // service oriented stuff
}
```

```
class UtilityService extend Service
{
  use PriceUtilities;
}
```

```
$p = new ShopProduct();
print $p->calculateTax(100) . "\n";

$u = new UtilityService();
print $u->calculateTax(100) . "\n";
```
使用 trait 关键字定义 PriceUtilities trait，其内容体跟类非常相似。一旦使用了 use 关键字紧接 trait 的名称，就可以从类中访问 PriceUtilities trait。所以只需要在一个地方声明并实现 calculateTax() 方法，然后包含到我们需要的类中即可。

### 使用多个 trait
可以使用 use 关键字列出多个 trait，并以逗号分隔。下面我们声明一个新的 trait，IdentityTrait。

```
trait IdentityTrait
{
  public function generateId(): string
  {
    return uniqid();
  }
}
```

```
class ShopProduct
{
  use PriceUtilities, IdentityTrait;
}
```
```
$p = new ShopProduct();
print $p->calculateTax(100) . "\n";
print $p->generateId() . "\n";
```
这样，我们就可以在 ShopProduct 类中使用 calculateTax() 和 generateId() 两个方法。


### trait 和接口的组合

尽管 trait 很有用，但是它不会更改使用它的类的类型。 因此，当你将 IdentityTrait 应用于多个类时，它们将不会共享方法签名中可能暗示的类型。幸运的是，trait 能配合接口发挥更多功能。我们定义一个包含 generateId() 方法的接口，然后在 ShopProduct 中实现它。

```
interface IdentityObject
{
  public function generateId(): string;
}
```
```
trait IdentityTrait
{
  public function generateId(): string
  {
    return uniqid();
  }
}
```

```
class ShopProduct implements IdentityObject
{
  use PriceUtilities, IdentityTrait;
}
```
与之前一样，ShopProduct 使用了 IdentityTrait。然而，这个导入的 generateId() 方法也实现了 IdentityObject 接口。这意味着我们可以以类型提示的方式将 IdentityObject 的实现对象传递给 ShopProduct 实例的方法和函数，如下所示：

```
public static function storeIdentityObject(IdentityObject $idobj)
{
  // do something with the identityObject
} 
```
```
$p = new ShopProduct();
self::storeIdentityObject($p);
print $p->calculateTax(100) . "\n";
print $p->generateId() . "\n";
```

### 使用 insteadof 解决方法名之间的冲突

组合 trait 的能力是个很好的特性，但早晚冲突是不可避免的。假如我们在引入的 trait 里都有 calculate() 方法：

```
trait TaxTools
{
  function calculateTax(float $price): float
  {
    return 222;
  }
}
```

```
trait PriceUtilities
{
  private $taxrate = 17;

  public function calculateTax(float $price): float
  {
    return (($this->taxrate / 100) * $price);
  }
  // other utilities
}
```

```
class UtilityService extendds Service
{
  use PriceUtilities, TaxTools;
}
```
```
$u = new UtilitiyService();
print $u->calculateTax(100) . "\n";
```
我们引入了包含 calculateTax() 方法的两个 trait，PHP 不知道到底使用哪个，所以出现致命的错误：

```
PHP Fatal error: Trait method calculateTax has not been applied, because there
are collisions with other trait methods on...
```
修复这个问题，可以使用 insteadof 关键字:

```
class UtilityService extends Service
{
  use PriceUtilities, TaxTools {
    TaxTools::calculateTax insteadof PriceUtilities;
  }
}
```
```
$u = new UtilityService();
print $u->calculateTax(100) . "\n";
```
为了对语句应用更多的指令，必须先添加一个主体（body），用花括号的形式展开。在花括号内，使用 insteadof 操作符。前面需要一个完全限定的方法引用，以范围操作符 `::` 的方式调用指定使用哪个 trait 里的方法：
```
TaxTools::calculateTax insteadof PriceUtilities;
```
清晰明了，直接从其英文语义就能得知代码的意思。

### 给 trait 方法起别名


